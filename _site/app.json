[{"name": "app.py", "content": "import datetime\nfrom typing import Dict, List, Optional, Tuple\n\nimport astropy.units as u\nimport matplotlib.dates as mpldates\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport pytz\nimport suntime\nimport timezonefinder\nfrom astropy.coordinates import AltAz, EarthLocation, SkyCoord\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, req, ui\n\nfrom location import location_server, location_ui\n\napp_ui = ui.page_fixed(\n    ui.tags.h3(\"Air mass calculator\"),\n    ui.div(\n        ui.markdown(\n            \"\"\"This Shiny app uses [Astropy](https://www.astropy.org/) to calculate the\n            altitude (degrees above the horizon) and airmass (the amount of atmospheric\n            air along your line of sight to an object) of one or more astronomical\n            objects, over a given evening, at a given geographic location.\n            \"\"\"\n        ),\n        class_=\"mb-5\",\n    ),\n    ui.row(\n        ui.column(\n            8,\n            ui.output_ui(\"timeinfo\"),\n            ui.output_plot(\"plot\", height=\"800px\"),\n            # For debugging\n            # ui.output_table(\"table\"),\n            class_=\"order-2 order-sm-1\",\n        ),\n        ui.column(\n            4,\n            ui.panel_well(\n                ui.input_date(\"date\", \"Date\"),\n                class_=\"pb-1 mb-3\",\n            ),\n            ui.panel_well(\n                ui.input_text_area(\n                    \"objects\", \"Target object(s)\", \"M1, NGC35, PLX299\", rows=3\n                ),\n                class_=\"pb-1 mb-3\",\n            ),\n            ui.panel_well(\n                location_ui(\"location\"),\n                class_=\"mb-3\",\n            ),\n            class_=\"order-1 order-sm-2\",\n        ),\n    ),\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    loc = location_server(\"location\")\n    time_padding = datetime.timedelta(hours=1.5)\n\n    @reactive.Calc\n    def obj_names() -> List[str]:\n        \"\"\"Returns a split and *slightly* cleaned-up list of object names\"\"\"\n        req(input.objects())\n        return [x.strip() for x in input.objects().split(\",\") if x.strip() != \"\"]\n\n    @reactive.Calc\n    def obj_coords() -> List[SkyCoord]:\n        return [SkyCoord.from_name(name) for name in obj_names()]\n\n    @reactive.Calc\n    def times_utc() -> Tuple[datetime.datetime, datetime.datetime]:\n        req(input.date())\n        lat, long = loc()\n        sun = suntime.Sun(lat, long)\n        return (\n            sun.get_sunset_time(input.date()),\n            sun.get_sunrise_time(input.date() + datetime.timedelta(days=1)),\n        )\n\n    @reactive.Calc\n    def timezone() -> Optional[str]:\n        lat, long = loc()\n        return timezonefinder.TimezoneFinder().timezone_at(lat=lat, lng=long)\n\n    @reactive.Calc\n    def times_at_loc():\n        start, end = times_utc()\n        tz = pytz.timezone(timezone())\n        return (start.astimezone(tz), end.astimezone(tz))\n\n    @reactive.Calc\n    def df() -> Dict[str, pd.DataFrame]:\n        start, end = times_at_loc()\n        times = pd.date_range(\n            start - time_padding,\n            end + time_padding,\n            periods=100,\n        )\n        lat, long = loc()\n        eloc = EarthLocation(lat=lat * u.deg, lon=long * u.deg, height=0)\n        altaz_list = [\n            obj.transform_to(AltAz(obstime=times, location=eloc))\n            for obj in obj_coords()\n        ]\n        return {\n            obj: pd.DataFrame(\n                {\n                    \"obj\": obj,\n                    \"time\": times,\n                    \"alt\": altaz.alt,\n                    # Filter out discontinuity\n                    \"secz\": np.where(altaz.alt > 0, altaz.secz, np.nan),\n                }\n            )\n            for (altaz, obj) in zip(altaz_list, obj_names())\n        }\n\n    @output\n    @render.plot\n    def plot():\n        fig, [ax1, ax2] = plt.subplots(nrows=2)\n\n        sunset, sunrise = times_at_loc()\n\n        def add_boundary(ax, xval):\n            ax.axvline(x=xval, c=\"#888888\", ls=\"dashed\")\n\n        ax1.set_ylabel(\"Altitude (deg)\")\n        ax1.set_xlabel(\"Time\")\n        ax1.set_ylim(-10, 90)\n        ax1.set_xlim(sunset - time_padding, sunrise + time_padding)\n        ax1.grid()\n        add_boundary(ax1, sunset)\n        add_boundary(ax1, sunrise)\n        for obj_name, data in df().items():\n            ax1.plot(data[\"time\"], data[\"alt\"], label=obj_name)\n        ax1.xaxis.set_major_locator(mpldates.AutoDateLocator())\n        ax1.xaxis.set_major_formatter(\n            mpldates.DateFormatter(\"%H:%M\", tz=pytz.timezone(timezone()))\n        )\n        ax1.legend(loc=\"upper right\")\n\n        ax2.set_ylabel(\"Air mass\")\n        ax2.set_xlabel(\"Time\")\n        ax2.set_ylim(4, 1)\n        ax2.set_xlim(sunset - time_padding, sunrise + time_padding)\n        ax2.grid()\n        add_boundary(ax2, sunset)\n        add_boundary(ax2, sunrise)\n        for data in df().values():\n            ax2.plot(data[\"time\"], data[\"secz\"])\n        ax2.xaxis.set_major_locator(mpldates.AutoDateLocator())\n        ax2.xaxis.set_major_formatter(\n            mpldates.DateFormatter(\"%H:%M\", tz=pytz.timezone(timezone()))\n        )\n\n        return fig\n\n    @output\n    @render.table\n    def table() -> pd.DataFrame:\n        return pd.concat(df())\n\n    @output\n    @render.ui\n    def timeinfo():\n        start_utc, end_utc = times_utc()\n        start_at_loc, end_at_loc = times_at_loc()\n        return ui.TagList(\n            f\"Sunset: {start_utc.strftime('%H:%M')}, \",\n            f\"Sunrise: {end_utc.strftime('%H:%M')} \",\n            \"(UTC)\",\n            ui.tags.br(),\n            f\"Sunset: {start_at_loc.strftime('%H:%M')}, \",\n            f\"Sunrise: {end_at_loc.strftime('%H:%M')} \",\n            f\"({timezone()})\",\n        )\n\n\n# The debug=True causes it to print messages to the console.\napp = App(app_ui, server, debug=False)", "type": "text"}, {"name": "location.py", "content": "from typing import Optional\n\nimport ipyleaflet as L\nfrom shiny import Inputs, Outputs, Session, module, reactive, req, ui\nfrom shinywidgets import output_widget, reactive_read, register_widget\n\n# ============================================================\n# Module: location\n# ============================================================\n\n\n@module.ui\ndef location_ui(\n    label: str = \"Location\",\n    *,\n    lat: Optional[float] = None,\n    long: Optional[float] = None,\n) -> ui.TagChildArg:\n    return ui.div(\n        ui.input_numeric(\"lat\", \"Latitude\", value=lat),\n        ui.input_numeric(\"long\", \"Longitude\", value=long),\n        ui.help_text(\"Click to select location\"),\n        output_widget(\"map\", height=\"200px\"),\n        ui.tags.style(\n            \"\"\"\n            .jupyter-widgets.leaflet-widgets {\n                height: 100% !important;\n            }\n            \"\"\"\n        ),\n    )\n\n\n@module.server\ndef location_server(\n    input: Inputs, output: Outputs, session: Session, *, wrap_long: bool = True\n):\n    map = L.Map(center=(0, 0), zoom=1, scoll_wheel_zoom=True)\n    with reactive.isolate():\n        marker = L.Marker(location=(input.lat() or 0, input.long() or 0))\n\n    with reactive.isolate():  # Use this to ensure we only execute one time\n        if input.lat() is None and input.long() is None:\n            ui.notification_show(\n                \"Searching for location...\", duration=99999, id=\"searching\"\n            )\n            ui.insert_ui(\n                ui.tags.script(\n                    \"\"\"\n                    navigator.geolocation.getCurrentPosition(\n                        ({coords}) => {\n                            const {latitude, longitude, altitude} = coords;\n                            Shiny.setInputValue(\"#HERE#\", {latitude, longitude});\n                        },\n                        (err) => {\n                            Shiny.setInputValue(\"#HERE#\", {latitude: 0, longitude: 0});\n                        },\n                        {maximumAge: Infinity, timeout: Infinity}\n                    )\n                    \"\"\".replace(\n                        \"#HERE#\", module.resolve_id(\"here\")\n                    )\n                ),\n                selector=\"body\",\n                where=\"beforeEnd\",\n                immediate=True,\n            )\n\n    @reactive.isolate()\n    def update_text_inputs(lat: Optional[float], long: Optional[float]) -> None:\n        req(lat is not None, long is not None)\n        lat = round(lat, 8)\n        long = round(long, 8)\n        if lat != input.lat():\n            input.lat.freeze()\n            ui.update_text(\"lat\", value=lat)\n        if long != input.long():\n            input.long.freeze()\n            ui.update_text(\"long\", value=long)\n        map.center = (lat, long)\n\n    @reactive.isolate()\n    def update_marker(lat: Optional[float], long: Optional[float]) -> None:\n        req(lat is not None, long is not None)\n        lat = round(lat, 8)\n        long = round(long, 8)\n        if marker.location != (lat, long):\n            marker.location = (lat, long)\n        if marker not in map.layers:\n            map.add_layer(marker)\n        map.center = marker.location\n\n    def on_map_interaction(**kwargs):\n        if kwargs.get(\"type\") == \"click\":\n            lat, long = kwargs.get(\"coordinates\")\n            update_text_inputs(lat, long)\n\n    map.on_interaction(on_map_interaction)\n\n    register_widget(\"map\", map)\n\n    @reactive.Effect\n    def _():\n        coords = reactive_read(marker, \"location\")\n        if coords:\n            update_text_inputs(coords[0], coords[1])\n\n    @reactive.Effect\n    def sync_autolocate():\n        coords = input.here()\n        ui.notification_remove(\"searching\")\n        if coords and not input.lat() and not input.long():\n            update_text_inputs(coords[\"latitude\"], coords[\"longitude\"])\n\n    @reactive.Effect\n    def sync_inputs_to_marker():\n        update_marker(input.lat(), input.long())\n\n    @reactive.Calc\n    def location():\n        \"\"\"Returns tuple of (lat,long) floats--or throws silent error if no lat/long is\n        selected\"\"\"\n\n        # Require lat/long to be populated before we can proceed\n        req(input.lat() is not None, input.long() is not None)\n\n        try:\n            long = input.long()\n            # Wrap longitudes so they're within [-180, 180]\n            if wrap_long:\n                long = (long + 180) % 360 - 180\n            return (input.lat(), long)\n        except ValueError:\n            raise ValueError(\"Invalid latitude/longitude specification\")\n\n    return location", "type": "text"}]